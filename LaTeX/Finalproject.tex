% ExCalCo.tex
% Source file of Extending Calculating Compilers

\documentclass {article}
\usepackage{amsmath}
\usepackage{theoremref}

\title{Calculating a correct compiler using the Bahr and Hutton method}
\author{Marco Jones}
\date{}
\makeglossary

\begin{document}
\maketitle

\tableofcontents

\newcommand{\BH}{Bahr and Hutton}
\newcommand{\vm}{virtual machine}

\section{Introduction}
\BH\ have developed a simple technique, for
calculating a compiler and virtual machine via equational reasoning
for a given source language and its' semantics \cite{bandh}, 
whilst simultaneously guaranteeing it's correctness by virtue 
of \emph{constructive induction}\glossary{Constructive induction} \cite{backhouse}.

Traditionally compilers are derived by %usual development of compilers, AST...
%Wand, Meijer, Ager et al

However through the inductive process we discover and invent definitions
of our compiler and virtual machine without needing consideration of an 
abstract syntax tree.
The result, is an equational program mainly consisting of
definitions of a pair functions,  ``comp'' and ``exec'',
representing the compiler and virtual machine, respectively.

The aim of this dissertation is to document the
application of this method
to a source language which extends upon the examples given in
Calculating Correct Compilers (CCC),
and will do so in three stages.

\subsection{Methodology}

Firstly by summarising the \BH\ method,
using the arithmetic language derivation as described in
CCC [Section 2], as a guide.

Secondly, the language will be gradually extended
by calculating new definitions of a more complex nature,
and implementing them in Haskell
\footnote{Haskell provides curried function application
		and explicit type declaration which are
		convenient for defining grammars,
		as consequence, the implementation closely
		resembles our calculations}.

After each of calculations we will verify
them, using an example expression
and few tests:

\begin{enumerate}
	\item Compare hand compiled code against the
		implemented compiler.
	\item Compare results of hand executed code 
		against that of the \vm.
	\item Compare outputs of the \vm\ against the interpreter.
	\item Prove the equations meet the specification\cite[page 14]{bandh}
\end{enumerate}

Thirdly, we will use automated testing,
should all tests pass, we will
be even more confident in our 
compiler's correctness

Finally, we will conclude with 
reflection on using the \BH\ method,
and further work.

%glossary:
%induction
%structural recursion
%source language
%scope


%\glossaryentry{Constructive induction}{12}

\subsection{The Bahr and Hutton method}

Sections 2.1 - 2.4 of CCC describe steps
1 - 4 of the method, only to have steps 2 - 4 combined
in section 2.5 \cite[2.5 Combining the transformation steps]{bandh},
resulting in a much simpler 3 step process, 
thus we will use their refined method\cite[page 12]{bandh}.

\begin{enumerate}
	\item Define an evaluation function
		in a compositional manner.
	\item Define equations that specify
		the correctness of the compiler.
	\item Calculate definitions that 
		satisfy these specifications.
\end{enumerate}

In section 2 they are deriving a compiler
and virtual machine for the ``Arithmetic'' language,
they begin by defining: a new Haskell data type $Expr$;
which contain the set of expressions which belong to their source language,
an evaluation function, also referred to as the \emph{interpreter},
which defines their semantics,
and a stack of integers 
``to make the manipulation of argument values explicit''.

	\[ \textbf{data} \  Expr = Val \ Int \, | \, Add \ Expr \ Expr\]

\newcommand{\eval}{$eval$}
\newcommand{\expr}{$Expr$}
\newcommand{\val}{$Val$}
\newcommand{\add}{$Add$}
\newcommand{\code}{$Code$}

\begin{eqnarray*}
	 eval &::& Expr \rightarrow Int \\ 
	 eval (Val \  n) &=& n \\
	 eval (Add \  x \  y) &=& eval \  x + eval \  y 
\end{eqnarray*}

	\[ \textbf{type} \, Stack = [Int]\]

\textbf{data} in Haskell creates a new type,
here we define \expr as either being a \val\
or an \add, these tags are called \emph{constructors},
a $Val$ constructor will always precede and integer
(which is ``Int'' in Haskell),
and an Add will always precede two more expressions.
It is the constructor \emph{together} with 
it's arguments that make it of \textbf{type}
expression, i.e $Val \ n$ or $Add \ x \ y$,
where $n$ is an $Int$ and $x$ and $y$ are $Expr$.
however because of curried function application,
we cannot simply write 
$eval \ Val \ n$ or $eval \ Add \ x \ y$,
because that applies \eval to 2 and 3 arguments respectively,
thus we package each expression into a single arguments
by using parentheses, so long as each is a
valid \expr, the function application will be type correct
and we may continue.

On the right hand side of the equations is a
description of how to compute 
the result when $eval$ is applied to $Val$ and
$Add$ expressions respectively.
$eval \ Val \ n$ simply returns $n$
on the other hand $eval \ Add \ x \ y$
is recursively defined as we do not yet know
the values of $x$ and $y$; \BH\ are defining the
semantics of $Add \ x \ y$ \emph{compositionally} by the 
semantics of each of it's argument expressions, $x$ and $y$.

Making the semantics compositional allows
the use of inductive proofs and definitions \emph{partial}
in the \BH\ method.
Although \BH\ explore
when this is not possible, that is beyond
the aim of this project \cite{bandh}.

In sections 2.1 - 2.4 \BH\
\emph{derived} four 
components and two correctness equations\cite{bandh}~[page~9]:

\begin{itemize}
	\item A data type $Code$ that represents
		code for the virtual machine.
	\item A function \( comp::Expr \, \rightarrow \, Code \)
		that compiles source expressions to code.
	\item A function 
		\( comp'::Expr \, \rightarrow \, Code \, \rightarrow \, Code \)
		that also takes a code continuation as input.
	\item A function
		\( exec::Code \, \rightarrow \, Stack \, \rightarrow \, Stack \)
		that provides a semantics for code by modifying a run-time stack.
\end{itemize}

\newtheorem{spec}{Specification}
\begin{spec}[Bahr and Hutton 3]
\thlabel{spec1}
	\[ exec \  (comp \  x) \  s = eval \  x:s \]
\end{spec}
\begin{spec}[Bahr and Hutton 4]
\thlabel{spec2}
	\[ exec \  (comp' \  x \  c) \ s = exec \  c \  (eval \, x:s) \]
\end{spec}

NB: \BH\ have labelled them 3 and 4 respectively, 
and will appear as 3 and 4 in quotations.

\newcommand{\exec}{$exec$}
\newcommand{\comp}{$comp$}
\newcommand{\compp}{$comp'$}

``Calculations begin with equations
of the form $exec \  (comp' \  x \  c) \  s$
as in equation (4),
and proceed by constructive induction on 
expression $x$, 
and aim to re-write it into the form
$exec \  c' \  s$ for some code $c'$
from which we can then conclude that the definition
$comp \  x \  c = c'$ satisfies the 
specification in this case.''\cite{bandh}

It is perhaps strange in appearance,
but this equation
specifies the correctness of compilation of our entire source code,
moreover all of the source code is contained within  $c'$
and we can manipulate all of it by induction.
A lot of compilers nowadays 
take entire programs as a (possibly huge) string of characters
and it is up to a preprocessor to collect them together into tokens \cite{dragon};
\comp, as we will see, translates the source code into a
list of instructions of type $code$ for the virtual machine to execute.

\subsection{Example calculations}

To introduce the \BH\ method,
we will follow the 
calculation of \comp\ and \exec\ definitions
for \val\ and \add\ expressions\cite[section 2.5]{bandh}.

Starting from \thref{spec1} and the expression $x$
being the base case $Val  \ n$, 
the calculation proceeds as follows\cite{bandh}:
%im paraphrasing here does that count?
(recall: \( eval (Val \  x) = n  \) )

\begin{align*}
	&exec \ (comp' \ (Val \ n) \ c) \ s \\
	&= \{ \} \\
	&exec \ c \ (eval \ (Val \ n) : s) \\
	&= \{definition \ of \ eval\} \\
	&exec \ c \ (n:s)
\end{align*}

Now there are no further definitions that we can apply,
but we can invent a definition for $exec$ which allows
us to continue by solving the equation:

	\[ exec \ c' \ s = exec \ c \ (n : s) \]

Currently we have the right hand side of this equation,
however $c'$ is a new variable only on one side of the equation
so we say it is \emph{unbound}.
In algebra, one cannot use an unknown variable to define
another without also making it's value unknown,
in the same way we can't use expressions with
unbound variables to define other expressions,
e.g \(y = x + z \ | where \ z = 1\), we cannot
know the value of $y$ if $x$ is not given.

``The solution is to package these two
variables up in the code argument $c'$
by means of a new constructor in the $Code$ data type
that takes these two variables as arguments,''

	\[ PUSH :: Int \rightarrow Code \rightarrow Code \]

``and define a new equation for exec as follows:''

	\[ exec \ (PUSH \ n \ c) \ s = exec \ c \ (n :s) \]

``executing the code $PUSH \ n \ c$ 
proceeds by pushing the value n onto the stack and
then executing the code $c$'', furthermore
we can see that we have $n$ and $c$ on both
sides of the equation and therefore no longer unbound.

\begin{align*}
	&exec \ c \ (n:s) \\
	&= \{definition \ of \ exec\} \\
	&exec \ (PUSH \ n \ c) \ s
\end{align*}

Our equation is now in the form $exec \ c' \ s$
where $c' = PUSH \ n \ c$, 
because we began from 
\(exec \ (comp' \ (Val \ n) \ c) \ s \),
and every equation was valid in the derivation,
it is safe to conclude that 

	\[exec \ (comp' \ (Val \ n) \ c) \ s = exec \ (PUSH \ n \ c) \ s\]

or more specifically, we have \emph{discovered} that 
	
	\( comp' \ (Val \ n) \ c =  PUSH \ n \ c \)

Next \BH\ calculate definitions for the inductive case, 
$Add \ x \ y$,
we call it inductive because we don't yet know 
the values of $x$ and $y$ however we are assuming
that they are expressions as well,
because otherwise there would be a type error.
Starting from a similar point,
(recall: \( eval (Add \  x \  y) = eval \  x + eval \  y  \) )

\begin{align*}
	&exec \ (comp' \ (Add \ x \ y) \ c) \ s \\
	&= \{specification \ (4) \} \\
	&exec \ c \ (eval \ (Add \ x \ y) : s) \\
	&= \{definition \ of \ eval\} \\
	&exec \ c \ (eval \ x + eval \ y :s)
\end{align*}

Again we are stuck, however using a similar process
as before, we can make a new definition for $exec$.
Moreover being an inductive case, 
we can make use of the induction 
hypotheses for $x$ and $y$\cite{bandh}.

\[exec \ (comp' \ x \ c) \ s = exec \ c \ (eval \ x:s) \]

\[exec \ (comp' \ y \ c) \ s = exec \ c \ (eval \ y:s) \]

Although all that is on top of the stack on the
RHS of this equation is $eval \ x$ or $eval \ y$,
but we want to use both values to make the addition.
The solution is to do one after the other,
but nonetheless we know we can have the top two 
stack elements to be $eval \ x$ or $eval \ y$.
Therefore we can use a new $Code$ constructor
that when executed, adds the top two stack elements
together and puts the result on top of the stack.

\begin{align*}
	&ADD :: Code \rightarrow Code \\
	&exec \ (ADD \ c) \ (m:n:s) = exec \ c \ ((n+m:s))
\end{align*}

Ordering is not important in this case; it is a matter of choice,
\BH\ mention here that their choice is to use
left-to-right evaluation by pushing $n$ 
or (as we will see)  $eval \ x$ on first,
again for consistency with CCC, 
I have used their definition.

Now we have the operation definition for the 
virtual machine we continue the calculation 

\begin{align*}
	&= \{ defintion \ of \ exec \} \\
	&exec \ (ADD c) \ (eval \ y : eval \ x : s) \\
	&= \{ induction \ hypothesis \ for \ y \} \\
	&exec \ (comp' y (comp' x (ADD c))) s
\end{align*}

We can conclude from this 
\[ exec \ (comp' \ (Add \ x \ y) \ c) \ s = exec \ (comp' y (comp' x (ADD c))) s \]

An important aspect of the \BH method
is that the equations that construct the 
compiler serve as proof of it's correctness,
and so they explain that a derivation such as
this one can be read as a proof \cite[page 14]{bandh}.
This will not show us much at the moment,
but will be used later on.

In summary \BH\ calculated the following definitions\footnote{
The instruction HALT simply returns the current state of the stack,
I didn't include \BH's derivation of HALT for brevity because
it's only a small point}
for the compiler and virtual machine:

\begin{eqnarray}
	&\textbf{data} \ Code &= HALT | PUSH Int Code | ADD Code \nonumber \\
	&comp &:: Expr \rightarrow Code \nonumber \\
	&comp \ x &= comp' \ x \ HALT \label{comp}\\
	&comp' &:: Expr \rightarrow Code \rightarrow Code \nonumber \\
	&comp' \ (Val \ n) \ c &= PUSH \ n \ c \label{comppval}\\
	&comp' \ (Add \ x \ y) \ c 
				&= comp' \ x \ (comp' \ y (ADD \ c)) \label{comppadd}\\
	&exec &:: Code  \rightarrow Stack \rightarrow Stack \nonumber \\
	&exec \ HALT \ s &= s \label{exechalt}\\
	&exec \ (PUSH \ n \ c) \ s &= exec \ c \ (n:s) \label{execpush}\\
	&exec \ (ADD \ c) \ (m:n:s) &= exec \ c \ ((n + m):s) \label{execadd}
\end{eqnarray}

\subsection{Testing Add and Val expressions}

To check these calculations, we can do several tests:
Calculate and compare by hand 
the code that is produced or executed
by the compiler definitions, 
against the results using the Haskell implementation in GHCi.
Compare the result of the executed code against the result
given by the interpreter. This result is arguably the most
important because if a counter example is found,
then our specification for 
compiler correctness 
\[ exec\ (comp'\ x\ c) s = exec\ c\ (eval\ x : s) \]
does not always hold.

%After these tests we can prove the equations meet the specification
%by the method that \BH describe in CCC \cite[page 14; derivation vs proof]{bandh}

To conclude this section I will test the functionality
of Add and Val, with a somewhat complicated
example.
This will give us a chance to look at the code that their
compiler generates and how the virtual machine executes it.

The equation we'll be looking at is:

\[ Add\ (Add\ (Val\ 0)\ (Val\ 1))\ (Val\ 2)) \]

This expression was chosen because it 
will test that each sub-expression
is compiled properly, 
this is more of a general test of the
\comp\ and \compp\ functions. 
In future we won't need to use
such complicated examples, 
especially when functions become more complicated.

\subsubsection{Compilation}

\begin{align*}
&comp\ (Add\ (Add\ (Val\ 0)\ (Val\ 1))\ (Val\ 2)) \\
&= \{ definition\ \ref{comp} \} \\
&comp'\ (Add\ (Add\ (Val\ 0)\ (Val\ 1))\ (Val\ 2))\ 			&(HALT) \\
&= \{ definition\ \ref{comppadd} \} \\
&comp'\ (Add\ (Val\ 0)\ (Val\ 1))\ (comp'\ (Val\ 2) 	  &(ADD\ HALT)) \\
&= \{ definitions\ \ref{comppadd}\ and\ \ref{comppval} \ \} \\
&comp'\ (Val\ 0)\ (comp'\ (Val\ 1)\		&(ADD\ (PUSH\ 2\ (ADD\ HALT)))) \\
&= \{ definition\ \ref{comppval}\ twice \ \} \\
&					 &PUSH\ 0\ (PUSH\ 1\ (ADD\ (PUSH\ 2\ (ADD\ HALT)))) \\
\end{align*}

This agrees with the same expression being compiled
using the Haskell implementation of the compiler.
GHCi: \( PUSH\ 0\ (PUSH\ 1\ (ADD\ (PUSH\ 2\ (ADD\ HALT)))) \)

\subsubsection{Execution}

The LHS contains the function representing our \vm\
and the RHS is the current state of the run-time stack

\begin{align*}
&exec\ (PUSH\ 0\ (PUSH\ 1\ (ADD\ (PUSH\ 2\ (ADD\ HALT))))) &[\, ] \\
&= \{ definition\ \ref{execpush}\ twice \} \\
&exec\ (ADD\ (PUSH\ 2\ (ADD\ HALT))) 					&[1,\ 0] \\
&= \{ definition\ \ref{execadd} \} \\
&exec\ (PUSH\ 2\ (ADD\ HALT)) 								&[1] \\
&= \{ definition\ \ref{execpush} \} \\
&exec\ (ADD\ HALT)										 &[2,\ 1] \\
&= \{ definition\ \ref{execadd} \} \\
&exec\ HALT 												&[3] \\
&= \{ definition\ \ref{exechalt} \} \\
&[3]
\end{align*}

\subsubsection{Interpretation}

\begin{eqnarray}
	 eval (Val \  n) &=& n \label{evalval}\\
	 eval (Add \  x \  y) &=& eval \  x + eval \  y \label{evaladd}
\end{eqnarray}

\begin{align*}
	&eval\ (Add\ (Add\ (Val\ 0)\ (Val\ 1))\ (Val\ 2)) \\
	&= \{ \ref{evaladd} \} \\
	&eval\ (Add\ (Val\ 0)\ (Val\ 1))\ +\ eval\ (Val\ 2) \\
	&= \{ \ref{evaladd} and \ref{evalval} \} \\
	&eval\ (Val\ 0)\ +\ eval\ (Val\ 1)\ +\ 2 \\
	&= \{ \ref{evalval}\ twice\} \\
	&0\ +\ 1\ +\ 2 \\
	&= \{ arithmetic \} \\
	&3
\end{align*}

These tests agrees with the same code being executed
using the Haskell implementation of the \vm.
GHCi: \( [3] \)


\subsubsection{Proof}

\begin{align*}
	&exec \ (comp' \ (Add \ x \ y) \ c) \ s \\
	&= \{specification \ (4) \} \\
	&exec \ c \ (eval \ (Add \ x \ y) : s) \\
	&= \{definition \ of \ eval\} \\
	&exec \ c \ (eval \ x + eval \ y :s) \\
	&ADD :: Code \rightarrow Code \\
	&exec \ (ADD \ c) \ (m:n:s) = exec \ c \ ((n+m:s)) \\
	&= \{ defintion \ of \ exec \} \\
	&exec \ (ADD c) \ (eval \ y : eval \ x : s) \\
	&= \{ induction \ hypothesis \ for \ y \} \\
	&exec \ (comp' y (comp' x (ADD c))) s
\end{align*}

%%%%%%%%%%%%%%%%%%%%	CONDITIONALS	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conditionals, $L_c$}

From now on this dissertation will report on my
investigation into applying the \BH\ method to develop a compiler
with definitions not defined in CCC.

To start off with, we will derive a conditional operator,
the purpose of this was to practise the method
on an operation only slightly more complicated than
the addition operation that \BH\ derived.

\newcommand{\ite}{$Ite$}

Step 1 is: 
``define an evaluation function in a compositional manner''.
We are still using the same \eval\ function from before,
but we need to define a new 
expression and it's semantics.

Haskell conditionals concrete
syntax ``if  x then y else z'',
however without a parser to do
lexical analysis\cite[chapter 2.2]{dragon} of the lexemes\footnote{
``if'', ``then'' and ``else'' in this case},
our \emph{source} language cannot use this
syntax, so we define ours abstractly.
In general conditionals are formed out of three parts:
a condition, a true case, and a false case.
In our language these will be three expressions
that follow an ``\ite'' constructor.

	\[ \textbf{data} \ Expr = ... | Ite \ Expr \ Expr \ Expr \]

the semantics of it will be

	\[eval(Ite\ x\ y\ z) \\
		= if\ eval\ x \not= 0 then\ eval\ y\ else\ eval\ z \]

The condition $eval \ x  \not= 0$ is very basic,
and we may benefit more from having variable conditions
which we could define at source level,
that could be done if we had an evaluation function 
that could return boolean values, 
however for the purpose of this calculation
this fixed condition will do.

More importantly, the semantics of \ite\
are compositional, 
again because we have defined it's
semantics in terms of the semantics of 
it's arguments so
calculations about \ite\ expressions
will be \emph{inductive}.

step 2: ``Define equations that specify the correctness of the compiler''.
The \exec\ and \comp\ functions still take the same
type of arguments as before,
so there is no need to update the specifications yet

\begin{eqnarray*}
	 &exec \  (comp \  x) \  s &= eval \  x:s \\
	 &exec \  (comp' \  x \  c) \ s &= exec \  c \  (eval \ x:s) 
\end{eqnarray*}

\subsection{Calculation}

Step 3: ``Calculate definitions that 
		satisfy these specifications''

In order to satisfy specification 2,
we begin with it's LHS where $x$ is our
\ite\ expression.

\begin{align*}
	&exec \ (comp' \ (Ite \ x \ y \ z) \ c) \ s \\
	&= \{specification \ (2) \} \\
	&exec \ c \ (eval \ (Ite \ x \ y \ z) : s) \\
	&= \{definition \ of \ eval\} \\
	&exec \ c \ (if \ eval \ x \ \not= 0 \ then \ eval \ y \ else \ eval \ z :s)
\end{align*}

There are no more definitions to apply from here,
it's clear that we required to
create a new definition for $exec$,
and because this is an inductive calculation
we can use the inductive hypotheses
just like with \BH's calculation of \add.

The inductive hypotheses are:
\begin{eqnarray*}
	exec \ (comp' \ x \ c) \ s &=& exec \ c \ (eval \ x:s) \\
	exec \ (comp' \ y \ c) \ s &=& exec \ c \ (eval \ y:s) \\
	exec \ (comp' \ z \ c) \ s &=& exec \ c \ (eval \ z:s)
\end{eqnarray*}

However, to be able to use them,
we must push $eval \ x,y,z$ onto the stack
in some order of our choice.
So we must solve the generalised equation:

	\[ exec \ c' \ (k:m:n:s) 
		= exec \ c \ (if \ k \not= 0 \ then \ m \ else \ n:s)\]

Our code constructor to solve this will be

	\[ ITE :: Code \rightarrow Code \]

and it's definition for the \vm

	\[ exec \ (ITE \ c) \ (k:m:n:s) 
		= exec \ c \ (if \ k \not= 0 \ then \ m \ else \ n:s) \]

i.e executing and ITE instruction
checks the top of the stack for the condition $k \not= 0$
and if so, then k and n are removed,
else k and m are removed.
Using this to continue the calculation, we have

\begin{align*}
	&exec \ c \ (if \ eval \ x \ \not= 0 \ then \ eval \ y \ else \ eval \ z :s) \\
	&= \{definition \ of \ exec\} \\
	&exec \ (ITE \ c) \ (eval \ x:eval \ y:eval \ z:s) \\
	&= \{induction\ hypothesis\ for\ x\} \\
	&exec \ (comp' \ x \ (ITE \ c)) \ (eval \ y:eval \ z:s) \\
	&= \{induction\ hypothesis\ for\ y\} \\
	&exec \ (comp' \ y \ (comp' \ x \ (ITE \ c))) \ (eval \ z:s) \\
	&= \{induction\ hypothesis\ for\ z\} \\
	&exec \ (comp' \ z (comp' \ y \ (comp' \ x \ (ITE \ c)))) \ s
\end{align*}

I conclude from this calculation these new definitions
for the compiler and \vm: 

\begin{eqnarray}
	comp' \ (Ite \ x \ y \ z) \ c &=&  comp' \ z \ (comp' \ y \ (comp' \ x \ (ITE \ c))) \label{compite}\\
	exec \ (ITE \ c) \ (k:m:n:s) &=& exec \ c \ ((if \ k \not= 0 \ then \ m \ else \ n):s) \label{execite}
\end{eqnarray}

\subsection{Testing}

For the testing, we can create an example \ite\ expression

	\[Ite \ (Val \ 1) (Add \ (Val \ 2) (Val \ 3)) (Add \ (Val \ 4) (Val \ 5)))) \]

This expression would test that
each of the sub-expressions 
(\add\ and \val) compile properly first, 
and that the result of the condition is correct
\footnote{
For completeness we would need to 
test both True and False outcomes of the condition,
such tests are included in the supporting Haskell files, 
however the by hand calculations are omitted
for brevity because they would not add much new
information to these series of tests}.

\subsubsection{Compilation}

\begin{align*}
	&comp' (Ite\ 
			(Val\ 1) 
			(Add\ (Val\ 2)\ (Val\ 3)) 
			(Add\ (Val\ 4)\ (Val\ 5))) \\
	&= \{ equation\ \ref{compite} \}\ \\ 
	&comp'\ (Add\ (Val\ 4)\ (Val\ 5))\\
		&(comp'\ (Add\ (Val\ 2)\ (Val\ 3))\\
			&(comp'\ (Val\ 1)\ (ITE\  HALT))) \\
	&= \{ equations\ \ref{comppadd}\ twice,\ and\ \ref{comppval}\ once\} \\
	&comp'\ (Val\ 4)\ 
		(comp'\ (Val\ 5)\ \\
				&(ADD\ (comp'\ (Val\ 2)\ 
						(comp'\ (Val\ 3)\ \\
							&(ADD\ (PUSH\ 1\ 
								(ITE\ HALT))))))) \\
	&= \{equation \ 3, \ 4 \ times \} \\
	&PUSH \ 4 (PUSH \ 5 (ADD (PUSH 2 (PUSH 3 (ADD (PUSH \ 1 \ (ITE \ HALT)))))))
\end{align*}

This agrees with the same expression being compiled
using the Haskell implementation of the compiler.
GHCi:
\[ PUSH\ 4(PUSH\ 5(ADD\ (PUSH\ 2(PUSH\ 3(ADD\ (PUSH\ 1(ITE\ HALT))))))) \]
	
\subsubsection{Execution}

In executing this code with an empty stack, we get: [5]

By hand, this calculation is as follows:
\begin{align*}
	&exec \, (PUSH \, 4 (PUSH \, 5 (ADD (PUSH \, 2 (PUSH \, 3(ADD(PUSH \, 1(ITE \, HALT)))))))) \ &[\, ] \\
	&= \{equation \ \ref{execpush}, twice\} \\ 
	&exec \ (ADD \ (PUSH \ 2 \ (PUSH \ 3 \ (ADD \ (PUSH \ 1 \ (ITE \ HALT)))))) \ &[5,4] \\
	&= \{equation \ \ref{execadd}\} \\
	&exec \ (PUSH \ 2 \ (PUSH \ 3 \ (ADD \ (PUSH \ 1 \ (ITE \ HALT))))) \ &[9] \\
	&= \{equation \ \ref{execpush}, twice\} \\ 
	&exec \ (ADD \ (PUSH \ 1 \ (ITE \ HALT))) \ &[3, 2, 9] \\
	&= \{equation \ \ref{execadd}\} \\
	&exec \ (PUSH \ 1 \ (ITE \ HALT)) \ &[5, 9] \\
	&= \{equation \ \ref{execpush}\} \\
	&exec \ (ITE \ HALT) \ &[1, 5, 9] \\
	&= \{equation \ \ref{execite}\} \\
	&exec \ HALT \ &[5] \\
	&= \{equation \ \ref{exechalt}\} \\
	&[5]
\end{align*}

Interpreting the expression\footnote{
Recall that the interpreter returns an Int rather than a stack}

	\[ eval\ (Ite\ (Val\ 1)\ (Add\ (Val\ 2)\ (Val\ 3))\ (Add\ (Val\ 4)\ (Val\ 5))) = 5\]

As the \vm\ and interpreter are in agreement,
we have shown an example of the compiler 
satisfying the compiler correctness specification

\[ exec \ c \ (eval \ (Ite \ x \ y \ z):s) 
	= exec (comp' \ (Ite \ x \ y \ z) c)  \ s  \]

\begin{align*}
	&exec \ c \ (eval \ (Ite \ x \ y \ z):s) \\
	&= \{definition \ of \ eval\} \\ 
	&exec \ c \ (if \ eval \ x \ \not= 0 \ then \ eval \ y \ else \ eval \ z :s) \\
	&= \{define\: exec \ (ITE \ c) (k : m : n : s) = exec \ c \ ((if \ k \not=0 \ then \ m : s\ else \ n) : s \} \\
	& exec \ (ITE \ c) \ (eval \ x : eval \ y : eval \ z : s) \\
	&= \{induction\ hypothesis \ for \ x \} \\
	& exec \ (comp' \ x \ (ITE \ c)) \ (eval \ y : eval \ z : s) \\
	&= \{induction\ hypothesis \ for \ y \} \\
	& exec \ (comp' \ y \ (comp' \ x \ (ITE \ c))) \ (eval \ z : s) \\
	&= \{induction\ hypothesis \ for \ z\} \\
	& exec \ (comp' \ z \ (comp' \ y \ (comp' \ x \ (ITE \ c)))) \ s \\
	&= \{definition \ of \ comp' \} \\
	& exec (comp' \ (Ite \ x \ y \ z) c)  \ s \\
	&QED
\end{align*} 

In retrospect, this kind of evaluation of the condition
is eager; both cases regardless of the
condition's result, are executed
while only one branch of code needs to be.
This can avoided at if we can instead
evaluate the condition at compile time
and throw away the code for the case
that we don't need to execute.

\subsection{Lazy evaluation}

\newcommand{\lite}{$Lite$}

Our ``Lazy if then else'' function
 will be called \lite.

	\[ \textbf{data} \ Expr = ... | Lite \ Expr \ Expr \ Expr \]

and it's semantics are

	\[eval(Lite \ x \ y \ z) = if \ eval \ x \ \not= 0 \ then \ eval \ y \ else \ eval \ z \]

which are the same as the semantics
of an \ite expression as 
expressions cannot be lazily evaluated,
%\begin{eqnarray}
%	eval(x) 
%\end{eqnarray}
because lazy evaluation means evaluating
something only when the evaluation function
is called on it,
so being able to lazily evaluate something 
by calling the evaluator on it,
would be contradictory.

\subsubsection{Calculation}

Our inductive calculation of \lite ,
begins in the same way
\begin{align*}
	&exec\ (comp'\ (Lite\ x\ y\ z)\ c)\ s \\
	&= \{specification\ (2) \} \\
	&exec\ c\ (eval\ (Lite\ x\ y\ z) : s) \\
	&= \{definition\ of\ eval\} \\
	&exec\ c\ (if\ eval\ x\ \not= 0 \ then\ eval\ y\ else\ eval\ z : s)
\end{align*}

Like with \ite our calculation halts here,
our aim with this time is that, again by using
the expression $x$ as our condition,
rather than deciding upon what value throw away
we instead decide upon two code branches, $ct$ and $ce$,
containing code of the complied $y$ and $z$ expressions.

	\[ LITE :: Code \rightarrow Code \rightarrow Code \]
	\[ exec\ (LITE\ ct\ ce)\ (eval\ x:s) 
	= exec\ c\ (if\ eval\ x\ \not= 0 \ then\ eval\ y\ else\ eval\ z : s \]

We cannot use this equation as a definition of exec 
because $c, \ y$ and $z$ are unbound in the 
body of the expression\cite[page 10]{bandh}.
However we can bind them in $ct$ and $ce$.
The compile function \compp requires that any code is followed by
more code (unless it is a HALT),
so not only do  $ct$ and $ce$ contain the code for expressions
 $y$ and $z$ but also the continuation code $c$

\begin{eqnarray*}
	ct &=& comp'\ y\ c \\
	ce &=& comp'\ z\ c
\end{eqnarray*}

In summary our generalised formal partial specification is
\begin{equation*}
	exec\ (LITE\ (comp'\ y\ c)\ (comp'\ z\ c) )\ (k:s) 
= exec\ (if\ k \not= 0\ then\ comp'\ y\ c\ else\ comp'\ z\ c)\ s 
\end{equation*}
which makes the rest of our calculation straightforward

\begin{align*}
	&exec\ c\ (if\ eval\ x\ \not= 0 \ then\ eval\ y\ else\ eval\ z : s) \\
	&= \{definition\ of\ exec\} \\
	&exec\ (LITE\ (comp'\ y\ c)\ (comp'\ z\ c) )\ (eval\ x : s) \\
	&= \{induction\ hypothesis\ for\ x\} \\
	&exec\ (comp'\ x ((LITE\ (comp'\ y\ c)\ (comp'\ z\ c)))\ s
\end{align*}

From which we may deduce 

	\[ comp'\ (Lite\ x\ y\ z)\ c 
		= comp'\ x ((LITE\ (comp'\ y\ c)\ (comp'\ z\ c))) \]

This method poses a problem;
on the right hand side of this equation,
$c$ appears twice, meaning the code not only 
doubles in length, but doubles in \emph{compile time}.
This would cause a compile time-complexity of
\( T(n) = \mathcal{O}(2^n) \)
where $n$ is the number of \lite\ expressions.
Surely there must be a way to avoid this.

The problem comes from the double use of $c$,
at the moment this is necessary because \compp
takes an \expr\ and \code\ as arguments and is in
each branch of code,
however they could instead \emph{share}
a code continuation if we used a different compile function
which would allow a single expression 
(and all sub-expressions contained within)  
to be compiled without continuation code of it's own,
unlike \compp, also LITE would need 3 code arguments in
it's constructor and we would need a way of 
reuniting the condition's code back with the rest of the code $c$
as $:\ cons$ would not work

\subsubsection*{Testing}

\begin{eqnarray*}
	f\ (Lite\ x\ y\ z)\ c &=& f'\ x ((LITE\ (f\ y)\ (f\ z)\ c)) \\
	exec\ (LITE\ (f\ y)\ (f\ z)\ c) (k : s) 
	&=& exec\ ((if \not=0 \ then\ (f\ y)\ else\ (f\ z)) : c)\ s 
\end{eqnarray*}

But this is an optimisation problem out of the scope of this dissertation.

%%$f$ would satisfy the equation
%%
%%\[ f \ (Lite \ x \ y \ z) \ c = comp' \ x ((FLITE \ (komp \ y) \ (komp \ z) c)) \]
%%
%%where FLITE has 3 \code arguments
%%and $komp e$ compiles $e$ without need of a continuation
%%FLITE :: Code \rightarrow Code \rightarrow Code \rightarrow Code 
%%
%%We cannot simply use \comp because it attaches an unwanted
%%HALT instruction onto the end of the code of both brances
%%
%%\(comp' \ x (LITE \ (comp \ y) \ (comp \ z) c) = PUSH \ 1 \ (LITE \ (PUSH \ 1 \ HALT) (PUSH \ 1 \ HALT))\)
%%
%%which would stop further execution of code
%%but because everything is type correct
%%
%%\(exec HALT c

To test our definitions we can use the Haskell compiler
to compile and execute an example \lite expression,
which will be the same expression as we used
on it's the eager twin for comparison.

	\[ exec \ (comp \ (Lite \ (Val \ 1) (Add \ (Val \ 2) (Val \ 3)) (Add \ (Val \ 4) (Val \ 5))))) \]

the result of comp: 
\begin{align*}	
	&comp \ (Lite \ (Val \ 1) (Add \ (Val \ 2) (Val \ 3)) (Add \ (Val \ 4) (Val \ 5))) \\
	&= PUSH \ 1 \ (LITE \ (PUSH \ 2 \ (PUSH \ 3 \ (ADD \ HALT))) (PUSH \ 4 \ (PUSH \ 5 (ADD \ HALT))))
\end{align*}

\begin{eqnarray}
	comp' \ (Lite \ x \ y \ z) \ c &=& comp' \ x (LITE \ (comp' \ y \ c) \ (comp' \ z \ c)) \\
	comp' \ (Add \ x \ y) \ c     &=&  comp' x (comp' y (ADD c)) \\
	comp' \ (Val \ n) \ c         &=&  PUSH \ n \ c
\end{eqnarray}

Compiling by hand:
\begin{align*}	
	&comp \ (Lite \ (Val \ 1) (Add \ (Val \ 2) (Val \ 3)) (Add \ (Val \ 4) (Val \ 5))) \\
	&= \{ definition \ of \ comp \ followed \ by \ equation \ 7 \ \} \\
	&comp' \ (Val \ 1) (LITE \ (comp' \ (Add \ (Val \ 2) (Val \ 3)) \ HALT) \ (comp' \ (Add \ (Val \ 4) (Val \ 5)))) \\
	&= \{ equation\ 9 \} \\
	&PUSH\ 1 \ (LITE \ (comp' \ (Add \ (Val \ 2) (Val \ 3)) \ HALT) \ (comp' \ (Add \ (Val \ 4) (Val \ 5)))) \\
	&= \{ equation \ 8 \ twice \} \\
	&PUSH\ 1\ (LITE \ ( comp' (Val \ 2) (comp' (Val \ 3) (ADD \ HALT)) \ (comp' (Val \ 4) (comp' (Val \ 5) (ADD \ HALT)))) \\
	&= \{ equation \ 9 \ four \ times \} \\
	&PUSH \ 1 \ (LITE \ (PUSH \ 2 \ (PUSH \ 3 \ (ADD \ HALT))) (PUSH \ 4 \ (PUSH \ 5 (ADD \ HALT))))
\end{align*}

So yet again, the expression has compiled correctly.

the result of exec: [5]

Which agrees with the interpretation of the expression:

	\[ eval \ (Lite \ (Val \ 1) (Add \ (Val \ 2) (Val \ 3)) (Add \ (Val \ 4) (Val \ 5)))  = 5\]

So we can move onto checking the execution by hand

\begin{eqnarray}
	exec \  (LITE \ ct \ ce) \ (k:s) &=&  exec (if \ k \ \not= 0 \ then \ ct \ else \ ce) \ s \\
	exec \ (PUSH \ n \ c) s         &=&  exec \ c \ (n:s) \\
	exec \  (ADD \ c) \ s     &=&  exec \ c \ ((n+m) : s) 
\end{eqnarray}
%equation 7 and 8 here are repeats from before,
% find a way to reset the numbering

\begin{align*}
	&exec \ (PUSH \ 1 \ (LITE \ (PUSH \ 2 \ (PUSH \ 3 \ (ADD \ HALT))) (PUSH \ 4 \ (PUSH \ 5 (ADD \ HALT))))) \ [] \\
	&=\{equation \ 11 \} \\
	&exec (LITE \ (PUSH \ 2 \ (PUSH \ 3 \ (ADD \ HALT))) (PUSH \ 4 \ (PUSH \ 5 (ADD \ HALT)))) \ [1] \\
	&=\{equation \ 10 \} \\
	&exec (PUSH \ 2 \ (PUSH \ 3 \ (ADD \ HALT))) \ [] \\
	&=\{equation \ 11 \ twice \} \\
	&exec (ADD \ HALT) \ [3, 2] \\
	&=\{equation \ 12 \} \\
	&exec \ HALT \ [5] \\
	&= \{definition \ of \ exec \} \\
	&[5]
\end{align*}


Finally we come to proving our calculation.
We aim to show that our definitions for \lite
satisfy the specification

	\[ exec \ c \ (eval \ (Lite \ x \ y \ z):s) = exec (comp' \ (Lite \ x \ y \ z) c)  \ s  \]

\begin{align*}
	&exec \ c \ (eval \ (Lite \ x \ y \ z):s) \\
	&= \{ definition \ of \ eval \} \\
	&exec \ c \ ((if \ eval \ x \ \not= 0 \ then \ eval \ y \ else \ eval \ z) :s) \\
	&= \{ define\: exec \ (LITE \ (comp' \ x \ c) (comp' \ y \ c) (k : s) \\
	&= exec \ (if \ k \not=0 \ then \ (comp' \ y \ c) \ else \ (comp' \ z \ c)) \ s \} \\
	& exec \ (LITE \ (comp' \ y \ c) \ (comp' \ z \ c)) \ (eval \ x : s) \\
	&= \{ definition \ of \ comp' \} \\
	& exec \ (comp' \ x \ (LITE \ 
							(comp' \ y \ c) \ 
							(comp' \ z \ c))) \ s \\
	&= \{definition \ of \ comp' \} \\
	&= exec (comp' \ (Lite \ x \ y \ z) c)  \ s \\
	QED
\end{align*}

\subsection{Summary}

In conclusion we have calculated the following definitions
												\cite[page 11]{bandh}:

\begin{eqnarray*}
	&\textbf{data} \ Code &= ...ITE\ Code | LITE\ Code\ Code \\
	&comp 				  &:: Expr \rightarrow Code \\
	&comp\ x			  &= comp'\ x\ HALT \\
	&comp'				  &:: Expr \rightarrow Code \rightarrow Code \\
	&comp'\ (Ite\ x\ y\ z) 
				&= comp'\ z\ (comp' \ y\ (comp' \ x\ (ITE c))) \\
	&comp'\ (Lite\ x\ y\ z) 
				&= comp'\ x\ (LITE\ (comp'\ y\ c)\ (comp'\ z\ c)) \\
	&exec\ (ITE\ c)\ (k:m:n:s) 
						&= exec\ c\ ((if\ k \not=0\ then\ m\ else\ n):s) \\
	&exec\ (LITE\ ct\ ce)\ (k:s) 
						&= exec\ (if\ k \not=0\ then\ ct\ else\ ce)\ s
\end{eqnarray*}

We have seen that via 
induction on the arguments of the 
\vm\ we can not only manipulate
stack elements but also code.
But our language is still very
basic.
Could we introduce more structures
to make the language more complicated;
with more features that resemble
an actual programming language?
\BH\ certainly do, by using 
multiple code continuations they
implement exception handling and the
``compilation techniques arising naturally''
through calculations\cite[page 24]{bandh}.

\section{Bindings, $L_b$}

Variables are a key component
of a lot of programming languages;
they allow users to easily reference
an object without needing to recompute.
Computers use memory to store information
which programs and programmers a like may
take advantage of.
Variables may be declared by \emph{binding}
a pair of two pieces of information:
a name, and a value.
Our \eval\ function as of yet 
cannot do such an operation
because it does not manipulate any kind of
data structure of it's own,
it only iterates through
expressions and interprets them.
\eval\ would require atleast one more argument
containing a set of bindings which it can
manipulate.

\subsection{Semantics}

step 1: define an evaluation 
	function in a compositional manner.

Our bindings structure will be called
an environment, it is a stack
of name-value pairs ($i$, $j$) where
a string $i$ paired to an integer $j$.
\newcommand{\env}{$Env$}

	\[ \textbf{type} \, Env = [(String,\ Int)]\]

The evaluation function needs to be updated
to take an \env\ as an argument as well as
an expression.

\begin{eqnarray*}
	&eval              	   		&::\  Expr \rightarrow Env \rightarrow Int \\
	&eval\ (Val\ n)\ bs 		&=   n \\
	&eval\ (Add\ x\ y)\ bs		&=   eval\ x\ bs\ +\ eval\ y\ bs \\
	&eval\ (Ite\ x\ y\ z)\ bs	&=   if\ (eval\ x\ bs) \not= 0\ then\ (eval\ y\ bs)\ else\ (eval\ z\ bs) \\
	&eval\ (Lite\ x\ y\ z)\ bs 	&=   if\ (eval\ x\ bs) \not= 0\ then\ (eval\ y\ bs)\ else\ (eval\ z\ bs)
\end{eqnarray*}

All of our functions
have been calculated without need of environments,
therefore we can be reasonably sure that simply adding in the
\env argument won't affect them\footnote{
brackets have been added around the expressions for ease of reading}.

\newcommand{\lets}{$Let$}
\newcommand{\var}{$Var$}

Now the expression that will make a binding,
we'll call ``\lets''.
\lets\ has the concrete syntax:
\( Let\ v = x\ in\ y\),
again without a parser to do
lexical analysis, we need to use
abstract syntax, and our constructor
for it

	\[ \textbf{data} \ Expr = ... |\ Let \ String \ Expr \ Expr \]

\lets\ creates a new binding,
by pushing the String-Int pair
onto the \env, to reference a variable we will
use a ``Var'' constructor

\[ \textbf{data} \ Expr = ... |\ Var \ String \]

The String is taken directly from the source
String part of the \lets\ expression,
however the value it's paired to 
needs to be computed inductively.

Therefore our semantics of \lets\ and \var\

\begin{eqnarray*}
&eval\ (Let\ v\ x\ y)\ bs &= eval\ y\ ((v,\ eval\ x\ bs):bs) \\
&eval\ (Var\ v)\ bs		    &=   valueOf\ v\ bs  \\
&valueOf\ &:: String \rightarrow Env \rightarrow Int \\
&valueOf \ s \ [\, ]\ &= error\ ``Binding\ out\ of\ scope?" \\
&valueOf\ s\ ((v,\ n):bs) &= if\ s == v\ then\ n\ else\ valueOf\ s\ bs
\end{eqnarray*}

valueOf is an auxiliary function,
it takes a string as input, iterates through an
environment, and attempts to match
the string to the strings in each binding.
It returns the value of the \emph{first}\footnote{
Should a variable name be bound to twice in a 
source expression and in the same scope,
only the latter binding will
be in effect} binding
to have a matching string. 
\linebreak

Sub-expressions inherit environments from their parent expressions,
and therefore the variables within them have the same \emph{scope},
except in the case of \lets\ where each sub-expression $x$ and $y$
has a different scope. 
To illustrate this, the following equations
have the resulting environment included on the RHS.
Our evaluator actually empties the environment 
after it's computation, 
but it's helpful to think of it like this

\begin{align}
eval\ (Add\ (Var\ ``a'')\ (Val\ 2))\ &[(``a'',\, 2)] 
			&= 4,\ [``a'',\, 2] \nonumber \\
eval\ (Let\ ``a''\ (Val\ 2)\ (Add\ (Var\ a)\ (Val\ 2))  )\ &[\, ] 
		&= 4,\ [(``a'',\, 2)] \nonumber \\ 
eval\ (Let ``b'' \nonumber \\
		(Let\ ``a''\ (Val\ 2) \
			 (Add\ (Var\ a)\ (Val\ 2))  ) \nonumber \\
		(Add\ (Var\ b)\ (Val\ 2)))\ &[\, ] 
		&= 6,\ [(``b'',\, 4),\ (``a'',\, 2)] \label{egletlet1} \\ 
eval\ (Let ``a'' \nonumber \\
		(Let\ ``b''\ (Val\ 2) \
			 (Add\ (Var\ a)\ (Val\ 2))  ) \nonumber \\
		(Add\ (Var\ b)\ (Val\ 2)))\ &[\, ] 
		&= ``Binding\ b\ out\ of\ scope'' \label{egletlet2} \nonumber \\
\end{align}

In equation (\ref{egletlet1})
the second \add\ inherits
the scope of \lets\ sub-expression 
preceding it, 
because it evaluates
\emph{within scope} of it.
Conversely with equation (\ref{egletlet2})
the first sub-expression tries to reference
a variable that is \emph{out of scope},
and our interpreter throws an error.



\subsection{Compiler Correctness}

Step 2: Define equations that specify the
	correctness of the compiler.

Our compiler specifications have been:

	\[ exec \  (comp \  x) \  s = eval \  x:s \]
	\[ exec \  (comp' \  x \  c) \ s = exec \  c \  (eval \, x:s) \]

However, these no longer hold
because our eval function has changed
with the introduction of environments,
therefore we need to update these equations.
\linebreak
Our \env\ specifies parings of 
variable names to values,
the compiler cannot compute any 
values on its own
but it can produce code that will
produce the same effect once executed.
Breaking down what the interpreter
does can indicate what the 
compiler and \vm\ should do.

\[eval(Let\ v\ x\ y)\ bs 
		= eval\ y\ ((v,\ eval\ x\ bs):bs) \]

NB: bs, although a new type it is just a list
of pairs, we could re-write it in equations as
[(vars, vals)] where vars are the variable names
and vals, their values,
but it is simpler to keep it as bs.

To evaluate a \lets, the interpreter
must do three things:
\begin{enumerate}
	\item Evaluate x in the current environment
	\item Bind the variable v to that value
	\item Evaluate y in the modified environment
\end{enumerate}

Clearly the compiler and \vm\ must have some kind of
environment of their own to
reflect changes in the environment.
The compiler cannot compute the value
parts of each pair,
it can however, 
store when and what variables are called.

\begin{eqnarray*}
	&\textbf{type}\  Context\ &= [String] \\
	&comp &::\ Expr \rightarrow Code \\
	&comp\ e &=\ comp'\ e\ [\,]\ HALT\ (*)\\
	&comp' &::\ Expr \rightarrow Context \rightarrow Code
\end{eqnarray*}

*\comp\ stays much the same except it's cxt
	is initially empty.

Remember, our aim at the moment
is to relate the compiler to the
semantics via a virtual machine.
If we tried to do update our compiler 
specifications now; 
without the proper definitions
for the \vm, we'd have

\begin{eqnarray*}
	&exec\ (comp\ x)\ s  
		&= exec\ (comp'\ x\ [\,]\ c)\ s  \\
	&exec\ (comp'\ x\ cxt\ c)\ s  
		&= exec\ c\ (eval\ x\ (Zip\ cxt\ vs):bs):s)
\end{eqnarray*}

Which cannot be used
because bs is still unbound.
bs is just a set of name-value pairs,
now we have variable names
that don't have paired values,
this can be left to the \vm.

We can use\footnote{
There may be a way to have the variable values
on the run-time stack, but it's
simpler to use a new one}
a new stack to
manipulate these variable values.
\exec should take as input
the a pair of:
it's current run-time stack,
and the values stack,
and then output the modified versions of both,
that is

\begin{eqnarray*}
	&\textbf{type}\ Memory\ &= (Stack,\ Stack) \\
	&exec &::\ Code \rightarrow Memory \rightarrow Memory \\
	&exec\ (comp'\ x\ cxt\ c) (s,\ vs) &= exec\ c\ ((eval\ x\ bs):s,\ vs)
\end{eqnarray*}

We now have a way of storing variable names
and their values, 
just in two different places.
To update the compiler correctness equations,
we need a function to pair up the names
to values.
That is the ``Zip'' function in Haskell

\begin{spec}
\thlabel{spec3}
	\[ exec\ (comp\ e)\ (s,\ vs) 
		= exec\ (comp'\ e\ [\,]\ HALT)\ (s,\ vs) \]
\end{spec}
\begin{spec}
\thlabel{spec4}
	\[ exec\ (comp'\ e\ cxt\ c)\ (s,\ vs) 
		= exec\ c\ ((eval\ e\ (Zip\ cxt\ vs):s,\ vs) \]
\end{spec}

Because our equations for \eval\
use the $bs$ symbol for environments,
it will be useful to formally state:

\begin{eqnarray}
&Zip\ (x:xs)\ (y:ys) &= (x,\, y):(Zip\ xs\ ys)  \\ \label{ziden}
&Zip\ cxt\ vs &= bs \label{zcxtvs}
\end{eqnarray}
	
These equations satisfy the full description
of step 2 in their \BH's General methodology
\cite[page 42]{bandh}.


\subsection{Calculation}

Step 3: Calculate definitions that satisfy
	the correctness of the compiler

Now that we have our compiler equations,
we can calculate definitions that satisfy
them by constructive rule induction
starting from the LHS of \thref{spec4}\cite[page 42]{bandh}.

\begin{align*}
	&exec\ (comp'\ (Let\ v\ x\ y)\ cxt\ c)\ (s,\ vs) \\
	&= \{ specification\ 4 \} \\
	&exec\ c\ (eval\ (Let\ v\ x\ y)\ (Zip\ cxt\ vs):s,\ vs) \\
	&= \{definition\ of\ Zip,\ definition\ of\ eval\} \\
	&exec\ c\ (eval\ y\ (\ (v,\ eval\ x\ bs) :bs) : s,\ vs)
\end{align*}

There are no more definitions to apply.

We aim to apply the inductive 
hypotheses for $x$ and $y$,
however our original ones will 
not do because they won't tell us
anything about changes of context.
We know, by the definition of our interpreter,
that $x$ needs to be evaluated first and 
bound to $v$ in the environment, so it can be 
referenced by any sub-expression
in $y$.
The Zip function connects the environment
to our context and values stacks.
To update an environment
we can use the definition of zip (\ref{ziden}),
where $x$ and $y$ are the new $v$ and $\chi$.

\[ Zip\ (v:xs)\ (\chi:ys) = (v,\, \chi):(Zip\ xs\ ys) = (v,\, \chi):bs \]

$y$ is evaluated with this environment.
Making the new inductive hypothesis for $x$ and $y$

\begin{eqnarray*}
	&exec\ (comp'\ x\ cxt\ c')\ (s,\ vs)
		&= exec\ c'\ (eval\ x\ bs : s,\ vs)\\
	&exec\ (comp'\ y\ (v:cxt)\ c'')\ (s,\ \chi : vs) 
		&= exec\ c''\ (eval\ y\ 
					(
					(v,\ \chi) : Zip\ cxt\ vs) : s,\ vs
					)\\
\end{eqnarray*}

NB:The code arguments are $c'$ and $c''$ 
here because we know we need a code instruction
to perform the binding, making it different to $c$,
and $c''$ is the code after the binding has been made.

To better fit the induction hypothesis for $y$,
apply the definition of Zip to the last step in the calculation
where \( \chi = eval\ x\ bs,\ bs = Zip\ cxt\ vs \)

\[ (v,\ eval\ x\ bs) :bs = (v,\, \chi):bs = (v,\, \chi):(Zip\ cxt\ vs) \]

To be able to use the induction hypothesis for $y$,
we need to have some value on $vs$ to take the place of $\chi$,
this value is unknown but is definitely an integer\footnote{
at the moment it's
type is the only thing that matters, not it's value,
but it will always be $\chi$\ because of the next step}.

\[ exec\ c''\ (s,\ \chi : vs) = exec\ c\ (s,\ vs) \]

Substituting the specific value $\chi$ for the general value $n$

\begin{eqnarray*}
&TEL\ &::\ Code \rightarrow Code \\
&exec\ (TEL\ c)\ (s,\ n:vs) &= exec\ c\ (s,\ vs)
\end{eqnarray*}

That is, $TEL$ removes the top the of the values stack.
A variable would have been bound to it as we will see,
but we will never be in a situation where we refer the wrong
value to a variable, because by construction a 

Using this to continue the calculation

\begin{align*}
&exec\ c\ (eval\ y\ (\ (v,\ eval\ x\ bs) :bs) : s,\ vs) \\
&= \{ definition\ of\ Zip \} \\
&exec\ c\ (eval\ y\ (v,\, \chi):(Zip\ cxt\ vs) : s,\ vs) \\
&= \{ definition\ of\ exec\ TEL\} \\
&exec\ (TEL\ c)\ (v,\, \chi):(Zip\ cxt\ vs) : s,\ \chi : vs) \\
&= \{ induction\ hypothesis\ for\ y \} \\
&exec\ (comp'\ y\ (v:cxt)\ (TEL\ c))\ (s,\ \chi : vs)
\end{align*}

Now to be able to use the induction hypothesis for $x$
we need a value to not be on $vs$ but rather on $s$.
We solve the equation 

\[ exec\ c'\ (\chi : s,\ vs) = exec\ c\ (s,\ \chi : vs) \]

Substituting the specific value $\chi$ for the general value $n$

\begin{eqnarray*}
 	&LET\ &::\ Code \rightarrow Code \\
 	&exec\ (LET\ c)\ (n:s,\ vs) &= exec\ c\ (s,\ n:vs)
\end{eqnarray*}

continuing the calculation

\begin{align*}
&exec\ (comp'\ y\ (v:cxt)\ (TEL\ c))\ (s,\ \chi : vs) \\
&= \{definition\ of\ exec\ LET\} \\
&exec\ (LET\ (comp'\ y\ (v:cxt)\ (TEL\ c)))\ (\chi : s,\ vs)\\
&= \{ \chi = eval\ x\ bs \} \\
&exec\ (LET\ (comp'\ y\ (v:cxt)\ (TEL\ c)))\ ((eval\ x\ bs) : s,\ vs)\\
&= \{ induction\ hypothesis\ for\ x \} \\
&exec\ (comp'\ x\ cxt\ (LET\ (comp'\ y\ (v:cxt)\ (TEL\ c))))\ (s,\ vs)
\end{align*}

From this we conclude
\[ comp'\ (Let\ v\ x\ y)\ cxt\ c
		= comp'\ x\ cxt\ (LET\ (comp'\ y\ (v:cxt)\ (TEL\ c))) \]

\subsection{Testing}










\bibliographystyle{IEEEtran}
\bibliography{calcob}
\end{document}